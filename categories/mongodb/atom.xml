<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: mongodb | Go ahead!]]></title>
  <link href="http://repeatedly.github.com/categories/mongodb/atom.xml" rel="self"/>
  <link href="http://repeatedly.github.com/"/>
  <updated>2012-10-29T09:00:08+09:00</updated>
  <id>http://repeatedly.github.com/</id>
  <author>
    <name><![CDATA[Masahiro Nakagawa]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[Collect invalid documents for bulk-insert in mongo-ruby-driver]]></title>
    <link href="http://repeatedly.github.com/2012/02/collect-invalid-documents-for-bulk-insert-in-mongo-ruby-driver/"/>
    <updated>2012-02-29T11:49:00+09:00</updated>
    <id>http://repeatedly.github.com/2012/02/collect-invalid-documents-for-bulk-insert-in-mongo-ruby-driver</id>
    <content type="html"><![CDATA[<p>Mongo gem 1.6.0 includes <a href="https://github.com/mongodb/mongo-ruby-driver/pull/82">my pull request</a>(and <a href="https://github.com/mongodb/mongo-ruby-driver/commit/a4343e53feb582103366bb9c02628a4c6b29fcbd">HISTORY</a>).</p>

<h2>Background</h2>

<p>Now, a service consists of many systems in production.
As a result, some systems insert broken or invalid data to MongoDB.</p>

<p>Here is problem.</p>

<p>mongo-ruby-driver's bulk-insert is dead or alive.
If inserting docs has one invalid docuemnt, then insert operation failed.
In addition, we can't find invalid documents.</p>

<p>This behavior is not usable.
We want to handle invalid documents,
e.g. output to local file, ignoring documents and etc.</p>

<p>My pull request resolves this problem.</p>

<h2>Usage</h2>

<p>I introduced <code>:collect_on_error</code> to <em>insert</em> options.</p>

<p><em>insert</em> without <code>:collect_on_error</code>:</p>

<p>```ruby</p>

<h1>docs is [{}, {}, ...]</h1>

<p>result = collection.insert(docs)
```</p>

<p><em>result</em> is an array of inserted document.</p>

<p><em>insert</em> with <code>:collect_on_error</code>:</p>

<p><code>ruby
result, invalid_docs = collection.insert(docs, :collect_on_error =&gt; true)
</code></p>

<p><em>result</em> is same as insert without <code>:collect_on_error</code>.
<em>invalid_docs</em> is an array of invalid document which removed ObjectId field.
We can handle <em>invalid_docs</em> manually.
For example, see <a href="https://github.com/fluent/fluent-plugin-mongo/commit/4656aa3948fce280158f718356f00764ea558ef9#L2R103">fluent-plugin-mongo</a>.</p>

<p>Enjoy MongoDB with Ruby!</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[Released fluent-plugin-mongo 0.6.0]]></title>
    <link href="http://repeatedly.github.com/2012/01/released-fluent-plugin-mongo-0.6.0/"/>
    <updated>2012-01-16T09:18:00+09:00</updated>
    <id>http://repeatedly.github.com/2012/01/released-fluent-plugin-mongo-0.6.0</id>
    <content type="html"><![CDATA[<p>Gem page is <a href="https://rubygems.org/gems/fluent-plugin-mongo">here</a>.</p>

<p>This version requires mongo gem version 1.5.2 for Replica Set.</p>

<h2>New features</h2>

<h3>Replica Set support</h3>

<p>You can use <em>mongo_replset</em> for connecting to Replica Set cluster.</p>

<p>Example configuration is below:</p>

<p>```apache
<match mongo.**>
  type mongo_replset
  database fluent
  collection logs</p>

<p>  # each node separated by ','
  nodes localhost:27017,localhost:27018,localhost:27019</p>

<p>  # num_retries is threshold at failover, default is 60.
  # If retry count reached this threshold, mongo plugin raises an exception.
  num_retries 30</p>

<p>  # following optional parameters passed to ReplSetConnection of mongo-ruby-driver.
  # See mongo-ruby-driver docs for more detail.
  #name replset_name
  #read secondary
  #refresh_mode sync
  #refresh_interval 60
</match>
```</p>

<h3>Handling invalid records</h3>

<p>Fluentd is an event collector, so Mongo plugin should handle an invalid record as a BSON.</p>

<p>Mongo plugin approach marshals an invalid record when mongo-ruby-driver detects such record.
And Mongo plugin inserts marshaled record as a broken data to same collection.</p>

<p>If passed following invalid record:</p>

<p><code>js
{"key1": "invalid value", "key2": "valid value", "time": ISODate("2012-01-15T21:09:53Z")}
</code></p>

<p>then Mongo plugin converts this record to following format:</p>

<p><code>js
{"__broken_data": Marshal.dump result of {"key1": "invalid value", "key2": "valid value"}, "time": ISODate("2012-01-15T21:09:53Z")}
</code></p>

<p>In the result, we can rescue and analyze a broken data later.</p>

<h4>NOTE</h4>

<p>Mongo-ruby-driver cannot detect an invalid attribute,
so Mongo plugin marshals all attributes excluding Fluentd keys("tag_key" and "time_key").</p>

<h4>Ignore an invalid record</h4>

<p>If you want to ignore an invalid record, set <em>ignore_invalid_document</em> parameter in match.</p>

<p>```apache
<match forward.*>
  ...</p>

<p>  # ignore invalid documents at write operation
  ignore_invalid_document true</p>

<p>  ...
</match>
```</p>

<h3>Tag mapped mode in <em>mongo</em> type</h3>

<p>0.6.0 merges <em>mongo_tag_collection</em> type into <em>mongo</em> type.
You can use <em>tag_mapped</em> parameter in <em>mongo</em> type for enabling tag mapped mode.</p>

<p>```apache
<match forward.*>
  type mongo
  database fluent</p>

<p>  # You use 'tag_mapped', then tag mapped mode enabled.
  tag_mapped</p>

<p>  # If tag is "forward.foo.bar", then prefix "forward." is removed.
  # Collection name to insert is "foo.bar".
  remove_tag_prefix forward.</p>

<p>  # This configuration is used if tag not found. Default is 'untagged'.
  collection misc</p>

<p>  # Other configurations here
</match>
```</p>

<h2>TODO</h2>

<ul>
<li>Support multi-process processing using DetachMultiProcessMixin</li>
<li>Support authentication if needed</li>
</ul>

]]></content>
  </entry>
  
</feed>
